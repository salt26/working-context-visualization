<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <title>Working context</title>
  <style>
    body {
      margin: 0;
    }
    .header {
      padding-left: 16px;
      padding-top: 0.5px;
      padding-bottom: 0.5px;
      text-align: left;
      background: #765EFF;
      color: white;
      font-size: 16px;
    }
    .setting {
      padding-left: 10px;
      padding-top: 6px;
      padding-bottom: 6px;
      background: #D1CCFF;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Working context</h1>
  </div>
  <div class="setting">
    <select id="date"></select>
    <select id="foreground-filter"></select>
    <input id="filter" type="number" min="1" max="20" value="10"/>
  </div>
  <div id="global"></div>
  <!--div id="foreground"></div>
  <div id="events"></div-->
  <div id="annotation"></div>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
    function translate(x, y) {
      return 'translate(' + x + ', ' + y + ')';
    }
    let svgWidth = screen.width;
    let svgHeight1 = (screen.height - 121.88) * 0.52;
    let svgHeight2 = (screen.height - 121.88) * 0.14;
    let svgHeight3 = (screen.height - 121.88) * 0.14;
    let margin1 = {top: 25, right: 25, bottom: 25, left: 140};
    let margin2 = {top: 25, right: 25, bottom: 25, left: 140};
    let margin3 = {top: 25, right: 25, bottom: 25, left: 140};
    let width1 = svgWidth - margin1.left - margin1.right;
    let width2 = svgWidth - margin2.left - margin2.right;
    let width3 = svgWidth - margin3.left - margin3.right;
    let height1 = svgHeight1 - margin1.top - margin1.bottom;
    let height2 = svgHeight2 - margin2.top - margin2.bottom;
    let height3 = svgHeight3 - margin3.top - margin3.bottom;
    let svg = d3.select("#global")
      .append('svg')
      .attr("viewBox", [0, 0, svgWidth, (screen.height - 121.88) * 0.66])
      .attr("width", "100%")
      .attr("height", "66%")
      .attr('class', 'svg')
    let svg1 = d3.select('.svg')
      .append('g')
      .attr("viewBox", [0, 0, svgWidth, svgHeight1])
      .attr('width', "100%")
      .attr('height', "52%")
      .attr('class', 'svg1')
      .append('g')
      .attr('transform', translate(margin1.left, margin1.top));
    let svg2 = d3.select('.svg')
      .append('g')
      .attr("viewBox", [0, 0, svgWidth, svgHeight2])
      .attr('width', "100%")
      .attr('height', "14%")
      .attr('transform', "translate(0, " + (screen.height - 121.88) * 0.52 + ")")
      .attr('class', 'svg2')
      .append('g')
      .attr('transform', translate(margin2.left, margin2.top));
    let svg3 = d3.select('#annotation')
      .append('svg')
      .attr("viewBox", [0, 0, svgWidth, svgHeight3])
      .attr('width', "100%")
      .attr('height', "14%")
      .attr('class', 'svg3')
    
    svg3
      .append('g')
      .attr('class', 'brush')
      .append('rect')
      .attr("fill", "#E7E5FF")
      .attr("x", margin3.left)
      .attr("y", margin3.top)
      .attr("width", svgWidth - margin3.left - margin3.right)
      .attr("height", svgHeight3 - margin3.top - margin3.bottom);
    
    svg3 = svg3
      .append('g')
      .attr('transform', translate(margin3.left, margin3.top));

    let clip1 = svg1.append("clipPath")
      .attr("id", 'clip1')
      .append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", width1)
      .attr("height", height1);
    svg2.append("clipPath")
      .attr("id", 'clip2')
      .append("rect")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", width1)
      .attr("height", height1);
    let graph1 = svg1.append('g')
      .attr('class', 'graph1');
    let graph2 = svg2.append('g')
      .attr('class', 'graph2');
    let graph3 = svg2.append('g')
      .attr('class', 'graph3');

    let files = [
      // Please add your data in the list!
      // {'filename': './Data/ChordingCoding_context_log_YYMMDD.csv', 'date': 'YYMMDD'},
      {'filename': './Data/ChordingCoding_context_log_221111.csv', 'date': '221111'},
    ];
    let allData = [];
    let foregroundData = [];
    let eventData = [];
    let processData = [];
    let annotationData = [];
    let ready = 0;
    
    function init() {
      files.forEach(function (x, i, a) {
        d3.csv(x.filename).then(function(d) {
          let newD = [];
          let newFD = [];
          let newED = [];
          let tempProcess = '';
          //let prevEventTime = new Date();
          d.forEach(function (row, index, array) {
            let newRow = { ...row,
              'id': index,
              'time': new Date(row.year, +row.month - 1, row.day, row.hour, row.minute, row.second, row.ms),
              'event': row.id === 'Process' ? 'Switch' : row.e,
              'process': row.id === 'Process' ? row.e : '',
              'window': row.w1 === '' ? '' : row.w2 === '' ? row.w1 : row.w3 === '' ? row.w1 + ',' + row.w2 : row.w1 + ',' + row.w2 + ',' + row.w3,
              'type': row.id === 'Key' ? 'Key stroke' : row.id === 'Mouse' && row.e !== 'MouseWheel' ? 'Mouse click' : row.id === 'Mouse' && row.e === 'MouseWheel' ? 'Mouse wheel' : ''
            };
            if (row.id === 'Process') {
              newFD.push(newRow);
              tempProcess = newRow.process;
            } else {//if (new Date(row.year, +row.month - 1, row.day, row.hour, row.minute) !== prevEventTime) {
              newRow.process = tempProcess;
              newED.push(newRow);
              //prevEventTime = new Date(row.year, +row.month - 1, row.day, row.hour, row.minute);
            }
            newD.push(newRow);
          });
          allData.push({'date': x.filename.substring(34, 40), 'data': newD});
          //console.log(allData)
          let newFD2 = [];
          let processList = [];
          //console.log(newFD)
          newFD.forEach(function (row, index, array) {
            let end = row.time;
            if (index + 1 < array.length) {
              end = array[index + 1].time;
            }
            else end.setSeconds(row.time.getSeconds() + 1);
            let fRow = { ...row,
              'end': end,
              'duration': Math.abs(row.time - end)
            }
            if (processList.find(e => e.process === fRow.process)) {
              processList.find(e => e.process === fRow.process).durationSum += fRow.duration;
            }
            else {
              processList.push({
                'process': fRow.process,
                'durationSum': fRow.duration
              });
            }
            newFD2.push(fRow);
          });
          //console.log(newFD2)
          processList.sort(function(a, b) {
            return b.durationSum - a.durationSum;
          });
          processData.push({'date': x.filename.substring(34, 40), 'data': processList});
          let newFD3 = [];
          newFD2.forEach(function (row, index, array) {
            let i = processList.findIndex(e => row.process === e.process);
            let fRow = { ...row,
              'order': i
            }
            newFD3.push(fRow);
          });
          foregroundData.push({'date': x.filename.substring(34, 40), 'data': newFD3});
          //console.log(newFD3);
          let prevTime = new Date(2021, 0, 1);
          let prevProcess = '';
          let count = 0;
          let onset = new Date(2021, 0, 1);
          let offset = new Date(2021, 0, 1);
          let aggrEData = [];
          let id = 0;
          ['Key stroke', 'Mouse click', 'Mouse wheel'].forEach(function (type) {
            newED.filter(row => row.type === type).forEach(function (event, index) {
                if (Math.abs(event.time - prevTime) > 10000 || prevProcess !== event.process) {
                  if (index > 0) {
                    offset = prevTime;
                    if (onset === offset) offset.setMilliseconds(onset.getMilliseconds() + 100);;
                    aggrEData.push({
                      'id': id,
                      'onset': onset,
                      'offset': offset,
                      'count': count,
                      'type': event.type,
                      'process': event.process
                    });
                    id += 1;
                  }
                  count = 0;
                  onset = event.time;
                }
                prevTime = event.time;
                prevProcess = event.process;
                count += 1;
              }
            )
          })
          eventData.push({'date': x.filename.substring(34, 40), 'data': aggrEData});
          //console.log(newED);
          
          let newAD = [];
          fetch("./Meta/Annotation_" + x.filename.substring(34, 40) + ".csv")
            .then(response => {
              if (!response.ok) {
                console.log(response);
                throw new Error("unable to fetch"); // TODO create new .csv file
              }
              return response.text();
            }).then(function (d){
              d3.csvParse(d, d3.autoType).forEach(function (row, index, array) {
                newAD.push(row);
              });
          });
          annotationData.push({'date': x.filename.substring(34, 40), 'data': newAD});

          ready += 1;
          
          if (ready == files.length){
            let dates = files.map(e => e.date);
            let dateSelect = d3.select('#date')
              .selectAll('option')
              .data(dates)
              .join('option')
              .append('option')
              .property('value', d => d)
              .text(d => d);

            let svg1XAxis = svg1.append('g')
              .attr('class', 'svg1XAxis')
              .attr('transform', translate(0, height1));
            let svg1YAxis = svg1.append('g')
              .attr('class', 'svg1YAxis')
              .attr('transform', translate(0, 0));
            let svg2XAxis = svg2.append('g')
              .attr('class', 'svg2XAxis')
              .attr('transform', translate(0, height2));
            let svg2YAxis = svg2.append('g')
              .attr('class', 'svg2YAxis')
              .attr('transform', translate(0, 0));
            let svg3XAxis = svg3.append('g')
              .attr('class', 'svg3XAxis')
              .attr('transform', translate(0, height3 / 2));
            let svg3YAxis = svg3.append('g')
              .attr('class', 'svg3YAxis')
              .attr('transform', translate(0, 0));

            update();
          }
        });
      });
    }

    function update() {
      if (ready < files.length) return;
      let date = d3.select('#date').node().value;
      //console.log(allData)
      let thisData = allData.find(e => e.date === date).data;
      let thisFData = foregroundData.find(e => e.date === date).data;
      let thisEData = eventData.find(e => e.date === date).data;
      let thisPData = processData.find(e => e.date === date).data;
      let thisAData = annotationData.find(e => e.date === date).data;
      let animationDuration = 1200;
      
      d3.select('#foreground-filter')
        .selectAll('option')
        .data([{'process': 'All'}].concat(thisPData), e => e.process)
        .join('option')
        .append('option')
        .property('value', d => d.process)
        .text(d => d.process);
      let foregroundFilter = d3.select('#foreground-filter').node().value;
      let processFilterNum = d3.select('#filter').node().value - 1;
      if (foregroundFilter !== "All") {
        //d3.select('#filter').attr("disabled", true);
        thisFData = thisFData.filter(e => e.process === foregroundFilter);
        thisEData = thisEData.filter(e => e.process === foregroundFilter);
      }
      if (processFilterNum < 0) processFilterNum = 0;
      else if (processFilterNum > thisPData.length) processFilterNum = thisPData.length;
      d3.select('#filter').property('value', processFilterNum + 1)

      let barX = d3.scaleTime()
        .domain([
          thisData[0].time,
          thisData[thisData.length - 1].time
        ])
        .range([0, width1])
      let filteredPData = thisPData.filter((d, i) => i < processFilterNum).map(d => d.process);
      filteredPData.push('others')
      let bar1YTick = d3.scaleBand()
        .domain(filteredPData)
        .range([0, height1]);
      let bar1YTickOthers = (process) => {
        let p = process;
        if (!(filteredPData.includes(p))) p = 'others'
        return d3.scaleBand()
          .domain(filteredPData)
          .range([0, height1])(p);
      }
      let bar1XAxis = d3.axisBottom(barX);
      let bar1YAxis = d3.axisLeft(bar1YTick);
      svg1XAxis = d3.select('.svg1XAxis')
        //.transition()
        //.duration(animationDuration)
        .call(bar1XAxis);
      svg1YAxis = d3.select('.svg1YAxis')
        //.transition()
        //.duration(animationDuration)
        .call(bar1YAxis);

      let bar1Color = (p) => {
        let processDomain = [
        'msedge','Code','explorer','Zoom','notepad',
        'KakaoTalk','WINWORD','AcroRd32','Acrobat','EXCEL',
        'ChordingCoding','GoogleDriveFS','rstudio','SnippingTool','slack',
        'NWC2','POWERPNT','chrome','devenv','obs64',
        'wmplayer','HncDic','Melon Player','powershell','putty',
        'audacity','Spotify','paintdotnet','mintty','WindowsTerminal'];
        if (!(processDomain.includes(p))) return '#404040'
        return d3.scaleOrdinal()
          .domain(processDomain)
          .range([
            '#2DC4CD', '#008AD3', '#FFD664', '#3F85F9', '#7BBAC9',
            '#FAE100', '#134DB2', '#F5463A', '#F5463A', '#0F783E',
            '#43E143', '#FFBA00', '#75AADB', '#E52D2D', '#E01E5A',
            '#00FFFF', '#BC3617', '#2D7CEE', '#A679DD', '#1B181B',
            '#F68D2B', '#996A34', '#1ED255', '#467AD6', '#0000FF',
            '#0000EB', '#1ED760', '#3969BA', '#F97F7C', '#404040'
          ])(p);
      }

      let bar2Y = d3.scaleBand()
        .domain(['Key stroke', 'Mouse click'])
        .range([0, height2]);
      let bar2XAxis = d3.axisBottom(barX);
      let bar2YAxis = d3.axisLeft(bar2Y);
      svg2XAxis = d3.select('.svg2XAxis')
        //.transition()
        //.duration(animationDuration)
        .call(bar2XAxis);
      svg2YAxis = d3.select('.svg2YAxis')
        //.transition()
        //.duration(animationDuration)
        .call(bar2YAxis);

      let bar2Color = d3.scaleOrdinal()
          .domain(['Key stroke', 'Mouse click'])
          .range(['#404040', '#404040', '#404040']);
      
      let bar3X = d3.scaleTime()
        .domain([
          thisData[0].time,
          thisData[thisData.length - 1].time
        ])
        .range([0, width1])
      let bar3Y = d3.scaleBand()
        .domain(['Work', 'Rest'])
        .range([0, height3]);
      let bar3XAxis = d3.axisBottom(barX);
      let bar3YAxis = d3.axisLeft(bar3Y);
      svg3XAxis = d3.select('.svg3XAxis')
        //.transition()
        //.duration(animationDuration)
        .call(bar3XAxis);
      svg3YAxis = d3.select('.svg3YAxis')
        //.transition()
        //.duration(animationDuration)
        .call(bar3YAxis);
      
      let bar1Enter = graph1.selectAll('rect')
        .data(thisFData, d => d.id)
        .enter()
        .append('rect')
        .attr('x', d => barX(d.time))
        .attr('width', d => Math.abs(barX(d.end) - barX(d.time)))
        .attr('y', d => bar1YTickOthers(d.process))
        .attr('height', bar1YTick.bandwidth())
        .attr("clip-path", 'url(#clip1)')
        .style('fill', d => bar1Color(d.process))
        //.style('opacity', 0)
        //.transition()
        //.delay(animationDuration)
        //.duration(animationDuration)
        .style('opacity', 1)

      let bar1Update = graph1.selectAll('rect')
        .data(thisFData, d => d.id)
        //.transition()
        //.duration(animationDuration)
        .attr('x', d => barX(d.time))
        .attr('width', d => Math.abs(barX(d.end) - barX(d.time)))
        .attr('y', d => bar1YTickOthers(d.process))
        .attr('height', bar1YTick.bandwidth())
        .attr("clip-path", 'url(#clip1)')
        .style('fill', d => bar1Color(d.process))
        .style('opacity', 1)

      let bar1Exit = graph1.selectAll('rect')
        .data(thisFData, d => d.id)
        .exit()
        //.transition()
        //.duration(animationDuration)
        //.attr('y', d => bar1YTickOthers(d.process))
        //.attr('height', bar1YTick.bandwidth())
        //.style('opacity', 0)
        .remove();
      
      let bar2Enter = graph2.selectAll('rect')
        .data(thisEData, d => d.id)
        .enter()
        .append('rect')
        .attr('x', d => barX(d.onset))
        .attr('width', d => Math.abs(barX(d.offset) - barX(d.onset)))
        .attr('y', d => bar2Y(d.type))
        .attr('height', bar2Y.bandwidth())
        .attr("clip-path", 'url(#clip2)')
        .style('fill', d => foregroundFilter === 'All' ? bar1Color(d.process) : bar2Color(d.type))
        .style('opacity', d => foregroundFilter === 'All' ? 1 : d.count * 200 / Math.abs(d.offset - d.onset))

      let bar2Update = graph2.selectAll('rect')
        .data(thisEData, d => d.id)
        .attr('x', d => barX(d.onset))
        .attr('width', d => Math.abs(barX(d.offset) - barX(d.onset)))
        .attr('y', d => bar2Y(d.type))
        .attr('height', bar2Y.bandwidth())
        .attr("clip-path", 'url(#clip2)')
        .style('fill', d => foregroundFilter === 'All' ? bar1Color(d.process) : bar2Color(d.type))
        .style('opacity', d => foregroundFilter === 'All' ? 1 : d.count * 200 / Math.abs(d.offset - d.onset))

      let bar2Exit = graph2.selectAll('rect')
        .data(thisEData, d => d.id)
        .exit()
        .remove();
      
      let bar3Enter = graph3.selectAll('rect')
        .data(thisAData, d => d.id)
        .enter()
        .append('rect')
        .attr('x', d => barX(d.start))
        .attr('width', d => Math.abs(barX(d.end) - barX(d.start)))
        .attr('y', d => bar3Y(d.annotation))
        .attr('height', bar3Y.bandwidth())
        .attr("clip-path", 'url(#clip3)')
        .style('fill', d => d.annotation === 'Work' ? '#765EFF' : '#413591')
        .style('opacity', 1)
  
      let bar3Update = graph3.selectAll('rect')
        .data(thisAData, d => d.id)
        .attr('x', d => barX(d.start))
        .attr('width', d => Math.abs(barX(d.end) - barX(d.start)))
        .attr('y', d => bar3Y(d.annotation))
        .attr('height', bar3Y.bandwidth())
        .attr("clip-path", 'url(#clip3)')
        .style('fill', d => d.annotation === 'Work' ? '#765EFF' : '#413591')
  
      let bar3Exit = graph3.selectAll('rect')
        .data(thisAData, d => d.id)
        .exit()
        .remove();

      function millisecondToStr(millisecond) {
        if (millisecond < 0) millisecond *= -1;
        let hour = Math.floor(millisecond / 1000 / 60 / 60);
        if (hour < 10) hour = "0" + hour;
        let minute = Math.floor((millisecond / 1000 / 60) % 60);
        if (minute < 10) minute = "0" + minute;
        let second = Math.floor(((millisecond + 500) / 1000) % 60);
        if (second < 10) second = "0" + second;
        return hour + ":" + minute + ":" + second;
      }

      bar1Enter.merge(bar1Update)
        .append("title")
        .text(function(d) {
          return "Process: " + d.process + "\nWindow title: " + d.window +
          "\nStart: " + d.time + "\nEnd:  " + d.end + "\nDuration: " + millisecondToStr(d.end - d.time);
        })

      bar2Enter.merge(bar2Update)
        .append("title")
        .text(function(d) {
          //console.log(d);
          return d.type + "\nProcess: " + d.process + "\nEvent count: " + d.count +
          "\nStart: " + d.onset + "\nEnd:  " + d.offset + "\nDuration: " + millisecondToStr(d.offset - d.onset);
        })
      
      let zoom1 = d3.zoom()
        .scaleExtent([1, 32])
        .extent([[0, 0], [width1, svgHeight1]])
        .translateExtent([[0, -Infinity], [width1, Infinity]])
        .on("zoom", zoomed);

      d3.select('.svg').call(zoom1);
      /*
      let noZoom = d3.zoom();

      d3.select('.svg1').on('keydown', (event) => {
        console.log(event);
        if (event.key === "Shift") {
          d3.select('.svg1').call(noZoom);
        }
      });
      d3.select('.svg1').on('keyup', (event) => {
        console.log(event);
        if (event.key === "Shift") {
          d3.select('.svg1').call(zoom1);
        }
      });

      d3.select('.svg2').on('keydown', (event) => {
        console.log(event);
        if (event.key === "Shift") {
          d3.select('.svg2').call(noZoom);
        }
      });
      d3.select('.svg2').on('keyup', (event) => {
        console.log(event);
        if (event.key === "Shift") {
          d3.select('.svg2').call(zoom1);
        }
      });

      d3.select('.svg3').on('keydown', (event) => {
        console.log(event);
        if (event.key === "Shift") {
          d3.select('.svg3').call(noZoom);
        }
      });
      d3.select('.svg3').on('keyup', (event) => {
        console.log(event);
        if (event.key === "Shift") {
          d3.select('.svg3').call(zoom1);
        }
      });
      */

      function zoomed(event) {
        //if (event.type === "start" || event.type === "brush" || event.type === "end") return;
        let xz = event.transform.rescaleX(barX);
        let scaleFactor = event.transform.k;

        //let selectionOldX1 = d3.select(".svg3").select(".selection").attr('x') * 1;
        //let selectionOldX2 = selectionOldX1 + (d3.select(".svg3").select(".selection").attr('width') * 1);
        graph1.selectAll('rect')
          .data(thisFData, d => d.id)
          .attr('x', d => xz(d.time))
          .attr('width', d => Math.abs(xz(d.end) - xz(d.time)));
        graph2.selectAll('rect')
          .data(thisEData, d => d.id)
          .attr('x', d => xz(d.onset))
          .attr('width', d => Math.abs(xz(d.offset) - xz(d.onset)));
        
          /*
        d3.select(".svg3")
          .select(".selection")
          .attr('x', xz3(barX.invert(selectionOldX1)))
          .attr('width', () => {
            console.log(selectionOldX2)
            let newWidth = xz3(barX.invert(selectionOldX2)) - xz3(barX.invert(selectionOldX1));
            selectionOldX1 = d3.select(".svg3").select(".selection").attr('x') * 1;
            selectionOldX2 = selectionOldX1 + newWidth;
            return newWidth;
          });
          */
        svg1XAxis.call(d3.axisBottom(xz));
        svg2XAxis.call(d3.axisBottom(xz));
        svg3XAxis.call(d3.axisBottom(xz));
      }

      
      let brush = d3.brushX()
        .extent([[margin3.left, margin3.top], [svgWidth - margin3.right, svgHeight3 - margin3.bottom]])
        .on("start brush end", brushed);

      let brushHandle = (g, s) => g
        .selectAll(".handle--custom")
        .data([{type: "w"}, {type: "e"}])
        .attr("display", s === null ? "none" : null)
        .attr("transform", s === null ? null : (d, i) => `translate(${s[i]},${margin3.top})`)
      
      function brushed(event) {
        //console.log(event);
        //if (event.type === "zoom") return;
        const selection = event.selection;
        if (selection === null) {
          const [mx] = d3.pointer(event, this);
          d3.select(this).call(brush.move, [mx, mx]);
          return;
        }
        const sx = selection.map(barX.invert);
        //circle.attr("stroke", d => sx[0] <= d && d <= sx[1] ? "red" : null);
        d3.select(this).call(brushHandle, selection);
      }

      let brushGroup = d3.select(".svg3")
        .append('g')

      brushGroup
        .call(brush)
        .call(brush.move, [0.3, 0.5].map(barX))

      d3.select(".svg3")
        .select(".selection")
        .attr("fill", "#765EFF")
        .attr("stroke", "#413591")
      
    }

    init();

    d3.select('#date').on('change', function(event, k) {
      update();
    });

    d3.select('#filter').on('change', function(event, k) {
      update();
    });

    d3.select('#foreground-filter').on('change', function(event, k) {
      update();
    });
  </script>
</body>